import streamlit as st
import rasterio
import folium
from streamlit_folium import folium_static
import branca.colormap as cm
import pandas as pd

st.set_page_config(
    page_title="Morocco Clima\u2013MAPS",
    page_icon="üó∫Ô∏è",
)

# Set Page Header   
st.markdown(
    """
    <div style="text-align:center">
        <h2>üåç Analyse G√©ospatiale avec COG (Cloud-Optimized GeoTIFF)</h2>
    </div>
    """,
    unsafe_allow_html=True,
)

# Set custom CSS for hr element
st.markdown("""
        <style>
            hr {
                margin-top: 0.5rem;
                margin-bottom: 0.5rem;
                height: 3px;
                background-color: #333;
                border: none;
            }
        </style>
    """, unsafe_allow_html=True)

# Add horizontal line
st.markdown("<hr>", unsafe_allow_html=True)

# Create tabs
tabs = ["Informations sur les COGS", "Exploration des COGs"]
st.sidebar.header("üìÇExploration des COGs")
selected_tab = st.sidebar.radio("S√©lectionnez une section", tabs)

# Section: Qu'est-ce qu'un COG?
if selected_tab == "Informations sur les COGS":
    st.markdown(
        """
        ### :blue[‚ñ∂ Qu'est-ce qu'un COG?]
        
        Un Cloud Optimized GeoTIFF (COG) est un fichier GeoTIFF standard, destin√© √† √™tre h√©berg√© sur un serveur de fichiers HTTP, avec une organisation interne qui permet des flux de travail plus efficaces sur le cloud. Pour ce faire, il exploite la capacit√© des clients √©mettant des requ√™tes de plage HTTP GET √† demander uniquement les parties d'un fichier dont ils ont besoin.
        """
    )
    st.markdown(
        """
        ### :blue[ ‚ñ∂ Avantages des COG dans l'Analyse G√©ospatiale:]

        - *Efficacit√© de Stockage:* Les COG permettent de stocker de grandes quantit√©s de donn√©es g√©ospatiales de mani√®re optimis√©e, r√©duisant ainsi les besoins de stockage.
        
        - *Acc√®s efficace aux donn√©es d'imagerie:* R√©duction du temps de traitement et de t√©l√©chargement complet du fichier.
       
        - *R√©duction de la duplication des donn√©es:* Divers logiciels acc√®dent tous √† un seul fichier en ligne et il √©vite aussi la duplication dans le cache.

        - *Compatibilit√© Cloud:* Les COG sont con√ßus pour fonctionner de mani√®re fluide dans des environnements cloud tels que AWS S3, Google Cloud Storage, ou Azure Blob Storage.
        """
    )
    st.markdown(
        """
        ### :blue[‚ñ∂ Comparaison entre GeoTIFF et COG :]
        
        """
    )

    feature_comparison_data = {
        "Fonctionnalit√©": ["Type de fichier", "R√©f√©rence g√©ographique", "Optimisation du cloud", "Soutien √† la compression", "Compatibilit√© SIG"],
        "GeoTIFF": ["raster", "Oui", "Non", "Oui", "Complet"],
        "COG": ["raster", "Oui", "Oui", "Oui", "Complet"]
    }

    # Create a DataFrame
    df_comparison = pd.DataFrame(feature_comparison_data)

    # Display the dataframe
    st.dataframe(df_comparison.set_index("Fonctionnalit√©"), width=800)

# Section: Exploration des COGs
elif selected_tab == "Exploration des COGs":
    st.markdown(
        """
        ### :blue[‚ñ∂ Exploration des COGs pour les donn√©es climatiques :]
        
        Explorez les donn√©es climatiques avec le format COG sur une carte interactive. Utilisez la barre lat√©rale pour personnaliser votre exp√©rience en fonction des donn√©es disponibles.üåê
        """
    )

    def load_cog_image(column_type, day_offset):
        column_mapping = {
            "üíß Humidit√©": "humcog",
        }

        if column_type not in column_mapping:
            raise ValueError(f"Le type de colonne {column_type} n'est pas pris en charge.")

        cog_url = f"https://cog2023.s3.eu-north-1.amazonaws.com/cog//{column_mapping[column_type]}{day_offset}.tif"
        
        with rasterio.Env():
            with rasterio.open(cog_url) as basemap:
                img = basemap.read(1)
                bounds = basemap.bounds

        return img, bounds

    def create_heatmap(column_type, day_offset=0):
        day = f'Jour {day_offset}' if day_offset >= 0 else f'Jour {abs(day_offset)} avant'

        # Create a folium map
        m = folium.Map(location=[29.985782, -8.668263], zoom_start=4.5)  # Coordonn√©es centr√©es sur le Maroc

        # Load the COG image for the selected column type and day
        basemap_image, bounds = load_cog_image(column_type, day_offset)

        # Ajuste les coordonn√©es pour encadrer la r√©gion du Maroc
        bounds = [[bounds.bottom, bounds.left], [bounds.top, bounds.right]]

        # Ajoute l'image GeoTIFF √† la carte Folium en utilisant la colormap viridis
        image_overlay = folium.raster_layers.ImageOverlay(image=basemap_image, bounds=bounds, opacity=1, colormap=lambda x: (0, 0, 1, x))
        image_overlay.add_to(m)

        # Create a colormap legend with custom min and max values
        if column_type == "üíß Humidit√©":
            colormap = cm.LinearColormap(colors=['white', 'blue'], vmin=0, vmax=50)
            colormap.caption = f'Legend - Min: 0, Max: 50 ({column_type})'
        else:
            colormap = cm.LinearColormap(colors=['white', 'blue'], vmin=basemap_image.min(), vmax=basemap_image.max())
            colormap.caption = 'Legend'
        
        # Add the legend to the map (positioned at the bottom-left)
        colormap.add_to(m)

        # Manually adjust the HTML to position the legend at the bottom-left
        html = f'<div style="position: fixed; bottom: 10px; left: 10px; z-index:1000;">{colormap._repr_html_()}</div>'
        m.get_root().html.add_child(folium.Element(html))
        folium.plugins.MiniMap().add_to(m)
        folium.plugins.Fullscreen().add_to(m)
        folium.plugins.MousePosition().add_to(m)
        folium.plugins.Draw(export=True, draw_options={'rectangle': True}).add_to(m)
        
        # Affiche la carte utilisant Streamlit et folium_static
        folium_static(m)

    df = pd.read_parquet(r"finalfinaaaaaaaaaal.parquet")
    
    # Display a dropdown to select the column type (Pr√©cipitation, Temperature, Humidit√©)
    selected_column_type = st.sidebar.selectbox("Choisir la donn√©e disponible", ["üíß Humidit√©"])
    selected_date = df["DATE"].min()
        
        # Utiliser st.date_input avec min_value et max_value pour bloquer la s√©lection
    st.sidebar.date_input(" üóìÔ∏è Date disponible", value=selected_date, min_value=selected_date, max_value=selected_date)
    # Display the slider for choosing the day offset
    day_offset = st.sidebar.slider("Choisir le jour", min_value=-6, max_value=0, step=1, value=0, key="day_slider")

    create_heatmap(selected_column_type, day_offset)
